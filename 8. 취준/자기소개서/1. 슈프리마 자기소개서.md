## ※ 본인 및 가족의 신상정보(신체조건, 출신지역, 재산, 직업, 학력 등)에 대한 내용은 작성 금지
### 지원하신 직무를 선택한 이유와, 이를 위해 기울인 노력을 구체적으로 작성해주세요.
몇 개의 프로젝트를 진행하며 다양한 포지션에서 개발을 해봤지만 서버 성능과 안정성을 고려한 백엔드 시스템을 설계하고 구현하는 과정에서 가장 큰 흥미를 느껴 SW Engineer 직무에 지원하였습니다.
단순히 기능을 빠르게 만드는 개발자가 아니라, 예외 상황을 고려한 설계와 테스트를 통해 안정적인 개발 환경을 구축하는 엔지니어로 성장하고자 하였습니다.
특히 슈프리마 BSS 부서의 TDD 기반 개발 문화, 코드 리뷰 중심의 협업 방식은 제가 지향하는 개발 방향과 맞닿아 있다고 느꼈습니다.
요구사항을 분석하고 알맞은 테스트 케이스를 도출해내는 능력을 갖춘 슈프리마의 환경에서 올바른 개발 습관을 체득하고, 팀의 품질 기준에 맞춰 성장하고 싶었습니다.

이를 위해 저는 Java Spring Boot를 중심으로 서버 개발 역량을 쌓아왔습니다.
MSA 기반의 프로젝트를 진행하면서 전체 프로그램을 돌려 기능을 확인하는 테스트 방식의 한계를 경험했고, 이후 테스트 전략을 단계화하였습니다.
비즈니스 로직은 외부 의존성을 Mock으로 분리한 단위 테스트로 빠르게 검증하고, DB/캐시/메시징과 같은 인프라 요소는 통합 테스트로 범위를 분리하여 테스트의 속도와 신뢰성을 함께 확보하려 했습니다.

구체적으로, 일정/할 일 서비스를 구현 중 이벤트가 발생하면 알림 서비스가 메시지 큐를 통해 알림을 생성하고 FCM을 통해 발송하는 구조를 구현한 경험이 있습니다.
초기에는 "전체 서비스를 실행시킨 뒤 시나리오 대로 따라가면 확인"하는 방식으로 테스트했었는데, 알림 서비스 장애나, 다른 서비스의 문제를 전부 반영하여 수정해야 해서 원인 파악에 어려움을 겪었습니다.
이를 개선하기 위해 알림 생성 로직은 단위 테스트로 분리하고 타 서비스의 EventProducer를 Mock 처리하여 정상 처리, 타임아웃/실패, 중복 이벤트 수신과 같은 케이스를 재현했습니다.
이 경험을 통해 MSA 환경에서는 외부 서비스의 구현을 신뢰하기보다, 계약과 실패 시나리오를 전제로 테스트를 설계하는 것이 중요하다는 점을 배웠습니다.

개발 생산성을 높이기 위해 Copilot 등 AI 도구도 활용하였습니다.
생성된 코드를 그대로 적용하기 보다는, 테스트 가능성 여부, 예외 처리, 성능 부분에서 개선 포인트를 요청하였고, 이를 리팩토링 하는 방식으로 사용하였습니다.
책임이 섞인 메서드를 분리하고, 실패 케이스가 불명확한 로직은 테스트 케이스를 먼저 추가한 뒤 구현을 보완하였습니다.

또한 C/C++ 프로젝트를 다수 진행하여 CS의 기본기를 갖추고 있습니다.
Shell 중에 기본이라 할 수 있는 Bash를 C를 이용해 직접 구현하는 minishell 프로젝트를 진행했었는데, Bash의 기능 중 하나인 "명령어 실행" 과 이 명령어 실행 결과를 이어줄 "파이프" 를 구현하기 위해 멀티 프로세스를 사용하였습니다. 
또한 멀티 스레드, 멀티 프로세스를 이용하여 데드락을 방지하여 식사하는 철학자 문제를 해결하였고, 게임 채팅으로 많이 사용되는 IRC 서비스를 C++을 이용해 멀티 플렉싱 기반의 Kqueue 를 사용하여 비동기 소켓 통신 서비스를 개발한 경험이 있습니다.

인턴십 기간 동안에는 주어진 업무를 수행하는 데 그치지 않고, 테스트 코드와 설계 관점에서 적극적으로 의견을 제시하며 팀에 기여하는 개발자가 되고 싶습니다. 
장기적으로는 슈프리마의 보안·인증 시스템을 이해하고, 안정성과 성능을 동시에 고려할 수 있는 백엔드 엔지니어로 성장해 회사의 기술 경쟁력에 기여하고자 합니다.
### 가장 열정을 가지고 임했던 일이나 프로젝트를 소개해주세요.
제가 가장 열정을 가지고 임했던 경험은 사회 문제해결 프로젝트 공모전에서 대상을 수상한 팀 프로젝트입니다.
당시 저희 팀은 실제로 겪어봐야 문제의 본질과 원인을 찾을 수 있다는 원칙을 세웠습니다.
저는 그 과정에서 현장 인터뷰와 공모전 발표를 담당하였고, 문제를 정의하고 설득하는 전 과정을 팀원들과 함께 하였습니다.

폐가죽이 재활용되지 않고 버려지는 문제의 실체를 파악하기 위해 저희는 성수 지역을 매일 방문하다시피 하며 상인분들과 인터뷰를 진행하였습니다.
저는 인터뷰 질문을 구성하고, 현장에서 반복적으로 관찰, 질문, 정리하며 어디에서 어떤 비용과 번거로움이 발생하는지, 왜 폐가죽이 일반쓰레기로 버려질 수 밖에 없는지에 대해 구체적으로 파악하였습니다.
그 결과, 단순히 수거를 늘리는 방식 등으로는 해결할 수 없고 실질적인 수거 프로세스의 변경이 필요하다는 것을 알게되었습니다.

해결안을 설계하는 과정에서 저희는 한정된 자원과 현실적으로 학생이 할 수 있는 운영 난이도를 최우선으로 고려하였습니다.
그래서 버려지는 가죽을 재활용하기 위해 "가죽을 직접 수거하여 분류"하는 복잡함을 버리고 분류 단계를 가죽을 버리는 소비자 쪽으로 앞당기는 방식을 제안했습니다.
구체적으로는 재활용 여부에 따라 색깔이 다른 가죽 포대를 각 가게에 제공하여 재활용 가능한 가죽과 활용 방식에 따라 분리 배출할 수 있도록 함으로써, 가게와 수거업체 모두 분류의 부담을 줄이고 재활용 가능성을 높이고자 하였습니다.
즉, 프로세스의 단순화를 통해 자연스럽게 원하는 결과를 얻도록 설계한 것입니다.
또한 저희는 매일 같이 성수 지역을 방문해야 했으며, 인터뷰 내용을 정리하고 발표 자료를 구성하는 많은 일을 해야 했기에 완성도를 높이기 위해 팀원들과 함께 방까지 잡으며 많은 시간을 이 프로젝트에 사용하였고 최종적으로 대상 수상이라는 성과로 이어질 수 있었습니다.

이 경험을 통해 저는 현장에서 요구사항을 검증하고 제약 조건을 반영해 해결안을 설계하는 프로세스를 경험할 수 있었고, 이러한 방식은 백엔드 개발에서도 동일하게 중요하다고 생각하며, 인턴십에서도 문제를 정확히 정의하고 검증 가능한 방식으로 해결안을 만들어 팀에 기여하겠습니다.
### 본인이 생각하는 본인의 강점과 약점을 설명해주세요.
저의 강점은 문제를 끝까지 ‘납득’될 때까지 파고들며, 시스템 관점에서 구조와 리스크를 먼저 생각하는 태도입니다. 단순히 기능을 구현하는 데서 멈추지 않고 “왜 이렇게 동작하는지”, “어떤 상황에서 깨질 수 있는지”를 끝까지 확인하려는 성향이 있습니다. 
실제로 MSA 환경에서 개발을 진행하며 서비스 간 연동이나 장애 상황을 고려하지 않은 채 전체 실행으로만 확인하는 방식의 한계를 체감했고, 이후에는 외부 의존성을 분리해 테스트 범위를 나누는 방식으로 접근하며 원인 추적과 개선이 가능한 구조를 만들고자 했습니다. 
또한 전교회장, 전교부회장, 동아리 부장 등 다양한 리더 경험 역할과 책임을 명확히 하고, 진행 상황을 투명하게 공유하는 협업 방식을 익혔습니다. 특히 목표와 일정, 담당 범위를 정리해 공유하고 주기적으로 진행 상황을 점검하는 습관이 이썽, 팀 내에서 커뮤니케이션 비용을 줄이고 협력을 원활하게 만드는 데 기여할 수 있습니다.
반면 약점은 정답을 빠르게 단정하기보다 완성도를 높이고 싶어하는 경향이 있습니다.
이 때문에 속도가 느려지는 경우가 있었는데 이를 보완하기 위해 최근에는 핵심 업무에 대해 우선 순위를 두어 최소 기능 MVP를 빠르게 만든 뒤 성능 측정과 테스트로 점진적으로 보강하는 방식으로 균형을 맞추고 있습니다.
큰 그림을 한 번에 다 잡기 보다는 단계적으로 확장시켜 팀의 개발 속도와 품질 기준을 동시에 만족시키는 엔지니어로서 팀에 기여하겠습니다.
### 어려움을 겪었을 때 이를 해결한 경험이 있다면 알려주세요.
프로젝트에서 비즈니스 로직이 복잡해지면서 예외 상황이 급격히 늘어났고, 그 결과 예외 처리 코드가 곳곳에 흩어져 유지보수가 어려워지는 문제를 겪었습니다.
초기에는 각 서비스/메서드에서 try-catch로 예외를 바로 처리하거나, 상황마다 다른 방식으로 메시지와 상태 코드를 반환하다 보니 같은 오류라도 응답이 제각각이었고, 예외가 추가될수록 가독성이 급격히 떨어졌습니다.
또한 어떤 예외를 사용자에게 알려야 하는지, 어떤 예외는 재시도가 필요한지 같은 기준이 불명확하여, 장애가 발생하였을 때 원인 파악과 해결법 탐색에 시간이 오래 걸렸습니다.

이 문제를 해결하기 위해 먼저 예외를 무작정 늘리는 방식에서 벗어나, 예외를 분류하고 처리 기준을 통일하는 것부터 시작했습니다.
예외를 크게 (1) 사용자 입력 오류, (2) 비즈니스 로직 오류, (3) 외부 의존성 오류, (4) 시스템 오류로 나누고, 각 분류별로 응답 코드와 메시지, 로그 레벨, 재시도 가능 여부를 정의하고자 하였습니다.
실제 응답 변환은 @ControllerAdvice 기반의 전역 예외 처리기로 일원화여 클라이언트에 보내주었습니다.

정리 이후에는 입력 경계값 문제, 외부 호출 실패 같은 케이스를 테스트로 고정하여, 예외가 추가되더라도 기존 동작이 깨지지 않도록 하였습니다.
그 결과 예외 처리 코드가 비즈니스 로직에서 분리되어 가독성이 늘었고, 코드 줄수도 200줄 가량 감소시킬 수 있었습니다.
오류 응답이 표준화 되었으며 테스트를 통해 일관된 설계가 가능하게 되었습니다.