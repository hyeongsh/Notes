# 자기소개
---
안녕하세요, 개발자 신형섭입니다.
작은 불편 하나가 쌓이면 결국 서비스 품질이 된다고 믿으며, 사용자가 체감하는 문제를 원인부터 구조적으로 해결하는 것을 좋아합니다.
minishell/irc 등으로 OS, 네트워크 기반을 다졌고, 최근에는 Life Dashboard를 MSA로 만들고 REST API, 메시징(RabbitMQ), 캐싱(Redis) 기반 기능을 개발하였습니다.
폴링 알림 방식의 문제를 파악하고 서버 주도 푸시 구조(FCM)로 전환하여 전력/트래픽 문제를 개선한 경험이 있습니다.


# 기술스택
---
### Language
- Java (Spring Boot 기반 백엔드)
- C/C++ (Bash 구현, IRC Server 구현)
- Python (라즈베리파이 게임 구현, 크롤링)
- JavaScript (Vanilla JS 프론트엔드 구현)
### Backend / framework
- Spring Boot (REST API, Spring Cloud Gateway, 인증/인가)
### Data / Cache
- MySQL
- Redis (ZSET 기반 스케줄 관리, 인덱싱 처리)
### Message
- RabbitMQ (이벤트 기반 비동기 처리, DLQ)
### Cloud / Infra
- AWS (EC2, RDS, S3, CloudFront, Route53, SSL/OAC)
- Docker / Docker-Compose
- GitHub Actions (CI/CD)
### Tools
- VS Code, IntelliJ
- Notion, GitHub
- Postman, Wireshark


# 프로젝트
---
## 올인원 라이프 대시보드
### 프로젝트 소개
*2025/8 ~*
To-Do, 일정, 공부 노트, 운동 기록 등 생활 전반의 데이터를 여러 앱에 흩어두지 않고, 하나의 서비스에서 통합 관리할 수 있는 올인원 대시보드를 개발했습니다.
요구사항 추가/변경에 빠르게 대응하고 서비스 확장을 용이하게 하기 위해 MSA 로 설계/구현했습니다.
Repository: https://github.com/orgs/betterlife-dashboard/repositories
### 수행 업무
- To-Do/Schedule/Note/Notification/Auth를 통합한 Life Dashboard 플랫폼을 기획, 개발하고, 개인 생활 데이터를 중심으로 도메인 모델과 서비스 구성을 설계
- Gateway 레벨에서 JWT 인증/인가를 중앙화하여 보안 로직을 단일화하고, 토큰 검증/예외/실패 응답 규격을 표준화
- RabbitMQ 이벤트 기반 알림 처리 파이프라인(이벤트 발행 -> 알림 생성 -> Redis ZSET 적재 -> 워커 소비 -> FCM 발송) 설계 /구현
- DLQ 기반 실패 처리 및 재시도 운영 전략을 설계하여 메시지 처리의 안정성과 장애 대응 가능성을 확보
- AWS 인프라(EC2, RDS, S3, CloudFront, Route53, SSL, OAC) 구성 및 배포 환경 운영, GitHub Actions 기반 CI/CD 자동화
- Flyway로 DB 마이그레이션/형상관리 체계를 구축하여 배포 시 스키마 변경 리스크를 관리
- 운영 비용 절감을 위해 홈서버 기반 온프레미스 인프라를 구축하고, 클라우드 운영 환경을 온프레미스로 마이그레이션 완료
- TDD + Testcontainers로 단위/통합 테스트를 구성해 기능 안정성을 확보하고, 인프라 연동 구간을 테스트 가능하게 설계
### 문제상황 및 해결
**알림 서비스 개선**
- *문제*: 초기 설계에서 빠른 구현을 위해 To-Do 알림을 5분 폴링 방식으로 구현하였으나, 이후 집중을 위한 타이머 구현 단계에서 1초마다 알림 API를 호출하게 되어 DB 쿼리 부하와 전력 과소모가 발생하였고, 재시도 폭증 문제가 발생하였습니다.
- *대안 시도 및 발생 이슈*: DB 부하를 줄이기 위해 기존에 DB에 저장하던 알림을 Redis로 이관하고, ZSET 기반으로 "발송 대상 알림"을 조회하는 방식으로 변경했습니다. 다만 클라이언트가 1초마다 API를 호출하는 구조 자체는 유지되어 전력 소모 및 요청 폭증 문제는 여전히 남아있었습니다.
- *해결 방안*: 저장 구조는 Redis Only + ZSET 스케줄링으로 유지하되, 클라이언트 폴링을 제거하고 FCM 푸시 방식으로 전환했습니다. 서버가 Redis에서 스케줄을 직접 탐색하고 발송하도록 구성해 클라이언트–서버 간 불필요한 요청을 제거했습니다.
- *결과*: 알림 조회에 대한 DB 접근을 제거하였고, 클라이언트 폴링 트래픽이 사라져 알림 조회 요청을 1시간 기준 인당 3600회 -> 0회(푸시 전환)로 감소시켰습니다.
## 스마트워치를 활용한 수면 보조 하드웨어 서비스
### 프로젝트 소개
*2024/9 ~ 2024/12*
수면 분석을 넘어 갤럭시워치 등 스마트워치를 활용한 수면 보조 서비스를 개발하여 현대 불면증을 해소시켜주기 위한 서비스입니다.
조명+음향장치를 넣은 하드웨어(ESP32)를 활용하여 수면을 위한 빛 조절 및 수면 유도 주파수를 제공합니다.
(Galaxy Watch, Android, ESP32, AWS Lambda)
Repository: https://github.com/orgs/Singirigojo/repositories
### 수행 업무
- 갤럭시워치/안드로이드 기반 수면 데이터 수집 앱 개발 및 서버 전송(REST API, Retrofit)
- AWS 서버리스 백엔드 설계/구현: API Gateway + Lambda로 앱 데이터 수집, DynamoDB 저장
- AWS IoT Core(MQTT) 기반 실시간 제어 파이프라인 구축: 센서 업링크/제어 다운링크 설계 및 연동
- 수면 진입 이벤트 기반 자동 제어 로직 설계: 수면 상태에 따라 조명 밝기/주파수 자동 조정
### 문제상황 및 해결
- *문제*: 삼성 헬스 api는 2024년 기준 파트너십이 되어 있어야 사용 가능했으며, 당시에는 파트너십이 닫혀있는 상태였습니다.
- *대안 시도*: 차선책으로 사용자가 수면에 들었다는 정보를 헬스 커넥트 api를 통해 받아와서 처리하고자 하였습니다.
- *발생 이슈1*: 수면 데이터가 언제 Health Connect에 동기화/저장될지 트리거가 불명확해 안정적으로 “수면 시작 시점”을 잡기 어려웠고, 초기에는 5분 간격 폴링 방식으로 대응했습니다.
- *발생 이슈2*: 수면 데이터 확인 과정에서 헬스 커넥트 데이터 안에 수면 데이터가 저장되는 것은 사용자가 삼성 헬스 앱을 켰을 경우에 전송되는 것을 확인하였고, 이 과정에서 팀원과의 협의를 통해 진행 방향을 결정해야 했습니다.
- *전환*: 팀 내 논의 후 외부 제약으로 인한 불확실성과 개발 속도 저하를 줄이기 위해 사용자가 수면 예정 시간을 지정하도록 제품 방향을 전환하고, 해당 시간 기준으로 조명/음향 제어가 동작하도록 구현하였습니다.
- *결과*: 연동 불확실성을 제거하여 구현 속도를 확보하였고, "시간 기반의 수면 보조 자동화" 기능을 안정적으로 완성할 수 있었습니다.
## FT_IRC
### 프로젝트 소개
*2024/6 ~ 2024/9*
RFC 2812 공식문서의 통신 규약을 지켜 소켓통신을 이용한 IRC 서버를 구축하였습니다.
I/O 멀티 플렉싱 방식의 소켓 통신과 RFC 통신 규약을 익힐 수 있었습니다.
Repository: https://github.com/InfpRC/INFPRC
### 수행업무
- IRC Server 구현 및 총괄 (팀 프로젝트, C++98): TCP/IP 기반 실시간 채팅 서버를 직접 구현 
- 다중 클라이언트 처리: 동시에 여러 클라이언트 연결을 관리하고 메시지 송수신을 안정적으로 처리하기 위해 I/O 멀티플렉싱(kqueue) 사용
- 채널/권한 모델 구현: 채널 운영자/일반 사용자 권한 분리 및 모드(초대 전용, 비밀번호 보호 등) 지원 
### 문제상황 및 해결
**메시지 파싱 오류**
- *문제*: 메시지가 길거나, 네트워크 이상으로 인해 메시지 전체가 아닌 일부만 먼저 도착하는 경우 메시지 파싱에 오류가 발생하였습니다.
- *원인 분석*: 원인을 찾아보니 TCP는 스트림이라 메시지의 경계를 보장해주지는 않는 통신 방식이었고, 데이터를 읽는 책임은 수신자에게 있다는 것이었습니다.
- *해결 방안*: 이를 해결하기 위해 클라이언트별로 read buffer를 따로 유지하여 CRLF(캐리지 리턴)이 도착하지 않는 한 read buffer에 누적 저장하도록 처리하였고, 버퍼는 문자열 길이에 제한이 없는 std::string을 사용하였습니다.
- *결과*: 버퍼보다 긴 문장이 오는 경우, 다중 명령이 한 번에 도착하는 경우 모두에서 정상적으로 명령이 처리되는 것을 확인했습니다.

**서버 효율성 개선**
- *문제*: 초기 설계에서 select를 사용하면 루프마다 모든 FD를 순회하며 상태를 확인해야 했고, 1000 클라이언트 동시 접속 테스트에서 30% CPU 사용률을 보였습니다.
- *대안 시도 및 발생 이슈*: 따라서 이벤트 기반으로 소켓을 확인하는 kqueue로 변경하여 1000 클라이언트 동시 접속 테스트를 진행하였으나 비슷한 수준인 25%의 CPU 사용률이 발생하였습니다.
- *원인 분석*: 원인을 분석해보니 이벤트 등록과 해제 전략이 없으면 이벤트 루프가 사실상 폴링처럼 동작할 수 있다는 걸 파악하였습니다. 
- *해결 방안*: 쓰기 이벤트는 송신 버퍼 값이 존재할 때만, 읽기 이벤트는 쓰기 이벤트가 없는 경우에만 등록하도록 하여 불필요한 처리를 감소시켰습니다.
- *결과*: 이를 통해 동일 테스트에서 CPU 사용률을 30% -> 10%로 20%p 개선하였습니다.
## MINISHELL
### 프로젝트 소개
*2023/11 ~ 2024/1*
GNU 공식문서를 참고하여 Bash 쉘의 기능을 구현한 minishell 프로젝트를 진행하며 멀티 프로세스, 파이프, 파일 제어, 시그널 처리 등을 학습하였습니다.
Repository: https://github.com/lamodadite/42seoul_minishell
### 수행업무
- fork() 기반 멀티프로세스 실행 모델을 구성하고 execve()로 외부 명령 프로그램을 실행하는 구조 구현 
- Pipe(|) 처리: 프로세스 간 파이프 연결 및 표준 입출력 흐름을 dup2()로 재지정하여 체인 실행 
- Redirection(<, >, >>, <<) 구현: 파일 디스크립터 제어로 입출력 전환 및 heredoc 처리 지원 
- Built-in(cd/echo/pwd/export/unset/env/exit) 구현 및 내장/외부 명령 분기 실행 경로 설계 
- 시그널 처리(Ctrl-C/Ctrl-D/Ctrl-\\)를 bash 쉘 요구사항에 맞게 구현
### 문제상황 및 해결
- *문제*: minishell 실행 중, 어느 순간 Ctrl-C 시그널이 더이상 동작하지 않고 무시되어 버리는 문제가 발생하였습니다.
- *원인 분석 과정1*: 멀티 프로세스 과정에서 생기는 문제라고 판단하여 실행하는 동안 프로세스 상태를 로그로 추적하며 좀비 프로세스가 생기는지 확인하였습니다.
- *원인 분석 과정2*: 또한 시그널 핸들러를 조작하는 위치를 찾아 해당 과정 종료 후 핸들러가 원상복구 되고 있는지 확인하였습니다.
- *원인 파악*: 문제 원인을 파악하니 heredoc 처리 후에도 SIGINT 무시 설정이 남아 있었기 때문이었습니다. 자식 프로세스를 생성하여 외부 명령을 실행할 때 부모 프로세스가 시그널에 대한 동작을 무시하고 돌아오면 원상복구되도록 처리해두었는데, 이와 마찬가지인 heredoc 처리에서 처리가 미흡하였습니다.
- *문제 해결*: heredoc 실행 종료 후 부모 프로세스의 시그널 핸들러를 복구하여 오류를 수정하였고, 단일 명령/파이프/리다이렉션/heredoc 조합에서 회귀 테스트로 재발을 방지하였습니다.
